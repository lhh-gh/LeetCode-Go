# [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)

## 题目
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]

## 题目大意



2 个逆序的链表，要求从低位开始相加，得出结果也逆序输出，返回值是逆序结果链表的头结点。
## 解题思路

这道题最优的做法时间复杂度是 O(n)。

通过模拟手算加法的过程，逐位相加并处理进位，最终生成一个新的链表，表示两个输入链表所代表的整数之和。
为了处理方法统一，可以先建立一个虚拟头结点，这个虚拟头结点的 Next 指向真正的 head，这样 head 不需要单独处理，直接 while 循环即可。另外判断循环终止的条件不用是 p.Next ！= nil，这样最后一位还需要额外计算，循环终止条件应该是 p != nil。入操作平均情况下是 O(1)

## 时间复杂度分析

循环次数：代码中的循环会持续进行，直到 l1 和 l2 都被遍历完，并且没有进位（carry 为0）。在最坏的情况下，两个链表的长度可能不同，但循环的次数不会超过两个链表长度之和。因此，循环的次数是 O(max(len(l1), len(l2)) + 1)，其中 len(l1) 和 len(l2) 分别是两个链表的长度。

循环内部操作：循环内部的操作（如赋值、加法和取模）都是常数时间操作，即 O(1)。

因此，总的时间复杂度是 O(max(len(l1), len(l2)))，这表示函数的执行时间与两个链表中较长的那个链表的长度成正比。


## 空间复杂度分析
结果链表：函数创建了一个新的链表来存储结果。在最坏的情况下，结果链表的长度可能等于两个输入链表长度之和（如果两个链表长度相同，且每个节点的值都是9，那么结果链表的长度将是输入链表长度的两倍减一，因为会有进位）。因此，结果链表的空间复杂度是 O(max(len(l1), len(l2)))。

辅助变量：函数中使用了少量的辅助变量（n1、n2、carry、current），这些变量的数量是固定的，不随输入链表的大小而变化，因此它们的空间复杂度是 O(1)。

哑节点：函数中创建了一个哑节点 head，它不随输入链表的大小而变化，因此其空间复杂度也是 O(1)。

综上所述，总的空间复杂度是 O(max(len(l1), len(l2)))，这表示函数使用的额外空间与两个链表中较长的那个链表的长度成正比。