# [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)

## 题目

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

## 题目大意

给定一个有序数组 nums，对数组中的元素进行去重，使得原数组中的每个元素最多暴露 2 个。最后返回去重以后数组的长度值。

## 解题思路

- 问题提示有序数组，一般最容易想到使用双指针的解法，双指针的关键点：移动两个指针的条件。
- 在该题中移动的条件：快指针从头遍历数组，慢指针指向修改后的数组的末端，当慢指针指向倒数第二个数与快指针指向的数不相等时，才移动慢指针，同时赋值慢指针。
- 处理边界条件：当数组小于两个元素时，不做处理。
  时间复杂度
  时间复杂度是指算法执行时间随输入数据规模增长的变化趋势。对于 removeDuplicates 函数：

## 时间复杂度
遍历数组：函数中有一个 for 循环，它遍历整个数组 nums。因此，这个循环的时间复杂度是 O(n)，其中 n 是数组 nums 的长度。

条件判断：在循环内部，有一个条件判断 if fast < 2 || nums[slow-2] != v，这个判断的时间复杂度是 O(1)，因为它只涉及常数数量的操作。

赋值操作：在循环内部，有一个赋值操作 nums[slow] = v，这个操作的时间复杂度也是 O(1)。

由于循环是主要的时间消耗操作，因此整个函数的时间复杂度主要由循环决定，即 O(n)。

## 空间复杂度
空间复杂度是指算法执行过程中临时占用存储空间的大小随输入数据规模增长的变化趋势。对于 removeDuplicates 函数：

输入数组：函数的输入是一个数组 nums，这个数组本身就是占用空间的，但是它不是由函数创建的，所以不算作函数的空间复杂度。

额外空间：函数中没有使用额外的数据结构来存储信息，除了几个变量（slow 和 fast）之外。这些变量占用的空间是常数级别的，因此空间复杂度是 O(1)。
