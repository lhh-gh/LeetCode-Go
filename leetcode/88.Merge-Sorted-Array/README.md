# [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/)

## 题目

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n
## 题目大意

合并两个已经有序的数组，结果放在第一个数组中，第一个数组假设空间足够大。要求算法时间复杂度足够低。

## 解题思路
因为输入的两个数组自身是有序的，所以我们只需要从后往前比较两个数组取最大的那个数放到nums1的后面
为了不大量移动元素，就要从2个数组长度之和的最后一个位置开始，依次选取两个数组中大的数，从第一个数组的尾巴开始往头放，只要循环一次以后，就生成了合并以后的数组了。
## 时间复杂度
第一个循环：这个循环从 p = m + n 开始，直到 m 和 n 都变为0。每次迭代，m 或 n 至少减少1，所以这个循环最多执行 m + n 次。
第二个循环：这个循环从 n > 0 开始，直到 n 变为0。这个循环最多执行 n 次。
因此，总的时间复杂度是两个循环的迭代次数之和，即 O(m+n)


## 空间复杂度
这段代码中没有使用额外的数据结构来存储合并后的数组，而是直接在 nums1 上进行操作。因此，空间复杂度是 O(1)，因为它只使用了常数级别的额外空间。