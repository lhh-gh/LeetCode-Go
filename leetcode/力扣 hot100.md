# 哈希
## 题号 1 
## 题名 两数之和

算法思路：
这道题最优的做法时间复杂度是 O(n)。

第一步：顺序扫描数组，对每一个元素，在 map 中找能组合给定值的另一半数字，如果找到了，直接返回 2 个数字的下标即可。
第二步：如果找不到，就把这个数字存入 map 中，等待扫到“另一半”数字的时候，再取出来返回结果。

## 题号 49
## 题名：字母异位词分组


算法思路：
第一步：将每个字符串都排序，排序完成以后，相同 Anagrams 的字符串必然排序结果一样。
第二步：把排序以后的字符串当做 key 存入到 map 中。
第三步：遍历数组以后，就能得到一个 map，key 是排序以后的字符串，value 对应的是这个排序字符串以后的 Anagrams 字符串集合。最后再将这些 value 对应的字符串数组输出即可。
 算法思路：
 1. 遍历每个字符串，将字符串转换为有序字符序列作为哈希键
 2. 将相同哈希键的字符串归类到同一分组
 3. 时间复杂度 O(n*klogk)，n为字符串数量，k为字符串平均长度

## 题号 128 

## 题名 最长连续序列

算法思路:

第一步：区间合并：当插入数字num时，通过查询num-1和num+1的区间长度，实现O(1)时间的区间合并

第二步：边界更新：更新num-left和num+right的边界值，确保后续合并操作的正确性

第三步：去重处理：通过检查numMap[num]避免重复处理相同数值

- 这一题最优的解法是解法一，针对每一个 `map` 中不存在的数 `n`，插入进去都做 2 件事情。
- 第一件事，先查看 `n - 1` 和 `n + 1` 是否都存在于 `map` 中，
- 如果都存在，代表存在连续的序列，那么就更新 `left`，`right` 边界。
- 那么 `n` 对应的这个小的子连续序列长度为 `sum = left + right + 1`。
- 第二件事就是更新 `left` 和 `right` 左右边界对应的 `length = sum`。

#  双指针

## 题号 283

## 题名 移动零


算法思路:
这一题可以只扫描数组一遍，不断的用 i，j 标记 0 和非 0 的元素，然后相互交换，最终到达题目的目的。


## 题号 11 

## 题名 盛最多的水的容器

算法思路:
这一题也是对撞指针的思路。首尾分别 2 个指针，每次移动以后都分别判断长宽的乘积是否最大。


## 15

## 三数之和


算法思路:
排序+ 双指针+ 三层去重


## 42

## 接雨水

算法思路:
双指针夹逼策略：通过维护左右两端的最大高度，动态计算每列能接的雨水量，实现时间复杂度 O(n) 和空间复杂度 O(1) 的高效解法。